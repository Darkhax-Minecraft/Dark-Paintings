plugins {
    id 'net.darkhax.curseforgegradle' version '1.0.7'
}

apply from: '../gradle/property_loader.gradle'
apply from: '../gradle/build_number.gradle'

import java.awt.image.BufferedImage
import javax.imageio.ImageIO
import groovy.json.JsonBuilder
import java.nio.file.Paths

def outputArchiveName = "${mod_name}-(Paitnings++)-${project.version}-${minecraft_version}.zip"

// This task will create a Paintings++ compatible resource pack using a mod's 
// resources folder.
task build(type: Zip) {

    mkdir buildDir
    createPaintingsFile()
    
    archiveName = outputArchiveName
    destinationDir = file("${buildDir}/libs/")
    includeEmptyDirs = false

    // Includes resources from the Common project.
    from (project(":Common").sourceSets.main.resources) {
    
        // Don't include any lang files. For now at least.
        exclude("**/assets/${mod_id}/lang/**")
    }
    
    // Includes the paintings++ manifest file.
    from file("${buildDir}/${mod_id}_paintings.json")
    
    // Replace tokens in source files while coppying them.
    filesMatching('pack.mcmeta') {
    
        expand project.properties
    }
    
    // Iterate the painting textures.
    filesMatching("**/assets/${mod_id}/textures/painting/**.png") {
        
        // Move texture from mod namespace to paintings++ namespace.
        it.path = Paths.get("/assets/paintings/textures/painting/${mod_id}_${it.getFile().name}")
    }
}

// Generates the paintings manifest file required by Paintings++
def createPaintingsFile() {
    
    // Map structure for the paintings++ json manifest.
    def paintingsData = [
      comment: "Paintings from the standalone ${mod_name} mod.", 
      comment_website: project.mod_homepage, 
      paintings: new ArrayList()
    ]
    
    // Includes resources from the common project. This is where multiloader
    // projects store their textures and other assets.
    project(":Common").sourceSets.main.resources.files.forEach { file ->
        
        // Only process painting texture files.
        if (file.path.contains("assets\\${mod_id}\\textures\\painting\\") && file.path.endsWith('.png')) {
        
            // Append the paintings data with info about this painting.
            paintingsData.paintings.add(createPainting(file))
        }
    }
    
    // Write the data to a file.
    file("${buildDir}/${mod_id}_paintings.json").text = new JsonBuilder(paintingsData).toPrettyString()
}

// Generates a paintings++ manifest entry from a painting texture.
def createPainting(File painting) {

    def image = ImageIO.read(painting)
    def name = "${mod_id}_${painting.name.substring(0, painting.name.length() - 4)}"
    def width = image.width
    def height = image.height
    
    // Whale Dream is a special case. 64x image for a 32x display area.
    if (name.contains('whale_dream')) {
    
        return [name: name, x: 32, y:32]
    }
    
    // When the width and height are the same it's a square.
    else if (width == height) {
    
        return [name: name, square: width]
    }
    
    // A normal paintings++ entry.
    return [name: name, x: width, y: height]
}

// CurseForge Publishing
task publishCurseForge(type: net.darkhax.curseforgegradle.TaskPublishCurseForge) {

    apiToken = findProperty('curse_auth')

    def mainFile = upload(paintings++_curse_project, file("${project.buildDir}/libs/${outputArchiveName}"))
    mainFile.changelogType = 'markdown'
    mainFile.changelog = "Updated to match ${version} of the [mod](${mod_homepage})."
    mainFile.addGameVersion(project.ext.minecraft_version)
}